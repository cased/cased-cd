var L = Object.defineProperty, N = Object.defineProperties;
var O = Object.getOwnPropertyDescriptors;
var $ = Object.getOwnPropertySymbols;
var S = Object.prototype.hasOwnProperty, z = Object.prototype.propertyIsEnumerable;
var w = (e, t, s) => t in e ? L(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, h = (e, t) => {
  for (var s in t || (t = {}))
    S.call(t, s) && w(e, s, t[s]);
  if ($)
    for (var s of $(t))
      z.call(t, s) && w(e, s, t[s]);
  return e;
}, v = (e, t) => N(e, O(t));
var d = (e, t, s) => new Promise((n, r) => {
  var a = (o) => {
    try {
      u(s.next(o));
    } catch (f) {
      r(f);
    }
  }, i = (o) => {
    try {
      u(s.throw(o));
    } catch (f) {
      r(f);
    }
  }, u = (o) => o.done ? n(o.value) : Promise.resolve(o.value).then(a, i);
  u((s = s.apply(e, t)).next());
});
import { normalizePath as D, fileURLToPath as I, isDev as F, isNextjsProject as H, getCodeWithWebComponent as Q } from "@code-inspector/core";
import p, { dirname as R } from "path";
function U(e, t) {
  return d(this, null, function* () {
    if (!e || !t)
      return [];
    const s = typeof e == "function" ? yield e() : e;
    let n = [];
    if (typeof s == "object" && !Array.isArray(s))
      for (const r in s) {
        const a = s[r], i = a.import || a;
        W(n, i, t);
      }
    else
      W(n, s, t);
    return n.filter((r) => !!r);
  });
}
function W(e, t, s) {
  typeof t == "string" ? e.push(_(t, s)) : Array.isArray(t) && e.push(
    ...t.map((n) => _(n, s))
  );
}
function _(e, t) {
  return p.isAbsolute(e) ? D(e) : e.startsWith(".") ? p.resolve(t, D(e)) : "";
}
let y = "";
typeof __dirname != "undefined" ? y = __dirname : y = R(I(import.meta.url));
let b = !0;
const V = (e, t) => {
  var a, i;
  if (!b)
    return;
  b = !1;
  const s = (t == null ? void 0 : t.compiler) || t, n = (a = s == null ? void 0 : s.options) == null ? void 0 : a.module;
  ((n == null ? void 0 : n.rules) || (n == null ? void 0 : n.loaders) || []).push(
    h({
      test: (i = e.match) != null ? i : /\.html$/,
      resourceQuery: /vue/,
      use: [
        {
          loader: p.resolve(y, "./loader.js"),
          options: e
        }
      ]
    }, e.enforcePre === !1 ? {} : { enforce: "pre" }),
    h({
      test: /\.(vue|jsx|tsx|js|ts|mjs|mts|svelte)$/,
      use: [
        {
          loader: p.resolve(y, "./loader.js"),
          options: e
        }
      ]
    }, e.enforcePre === !1 ? {} : { enforce: "pre" }),
    v(h({}, e.injectTo ? { resource: e.injectTo } : {
      test: /\.(jsx|tsx|js|ts|mjs|mts)$/,
      exclude: /node_modules/
    }), {
      use: [
        {
          loader: p.resolve(y, "./inject-loader.js"),
          options: e
        }
      ],
      enforce: H() ? "pre" : "post"
    })
  );
};
function k(e, t) {
  return Q({
    options: v(h({}, e), { importClient: "code" }),
    file: "main.js",
    code: "",
    record: t,
    inject: !0
  });
}
function q(n) {
  return d(this, arguments, function* ({
    options: e,
    record: t,
    assets: s
  }) {
    const r = Object.keys(s).filter((a) => /\.html$/.test(a));
    if (r.length) {
      const a = yield k(e, t);
      r.forEach((i) => {
        var o, f;
        const u = (f = (o = s[i]) == null ? void 0 : o.source) == null ? void 0 : f.call(o);
        if (typeof u == "string") {
          const c = u.replace(
            "<head>",
            '<head><script type="module">\n'.concat(a, "\n<\/script>")
          );
          s[i] = {
            source: () => c,
            size: () => c.length
          };
        }
      });
    }
  });
}
class K {
  constructor(t) {
    this.options = t;
  }
  apply(t) {
    return d(this, null, function* () {
      var n, r, a, i, u, o, f, c, x, A, P, j, C;
      if (b = !0, this.options.close || !F(
        this.options.dev,
        ((n = t == null ? void 0 : t.options) == null ? void 0 : n.mode) === "development" || process.env.NODE_ENV === "development"
      ))
        return;
      const s = {
        port: 0,
        entry: "",
        output: this.options.output,
        inputs: U(
          (r = t == null ? void 0 : t.options) == null ? void 0 : r.entry,
          (a = t == null ? void 0 : t.options) == null ? void 0 : a.context
        ),
        envDir: (i = t == null ? void 0 : t.options) == null ? void 0 : i.context,
        root: (u = t == null ? void 0 : t.options) == null ? void 0 : u.context
      };
      if (((f = (o = t == null ? void 0 : t.options) == null ? void 0 : o.cache) == null ? void 0 : f.type) === "filesystem" && (this.options.cache ? k(this.options, s) : t.options.cache.version = "code-inspector-".concat(Date.now())), ((A = (x = (c = t == null ? void 0 : t.options) == null ? void 0 : c.experiments) == null ? void 0 : x.cache) == null ? void 0 : A.type) === "persistent" && (this.options.cache ? k(this.options, s) : t.options.experiments.cache.version = "code-inspector-".concat(Date.now())), V(v(h({}, this.options), { record: s }), t), (P = t == null ? void 0 : t.hooks) != null && P.emit && !((C = (j = this.options.skipSnippets) == null ? void 0 : j.includes) != null && C.call(j, "htmlScript"))) {
        const E = this.options;
        t.hooks.emit.tapAsync(
          "WebpackCodeInspectorPlugin",
          (g, T) => d(this, null, function* () {
            let l = {};
            g.getAssets ? l = yield g.getAssets() : l = g.assets, yield q({
              options: E,
              record: s,
              assets: l
            }), T();
          })
        );
      }
    });
  }
}
export {
  K as default
};
