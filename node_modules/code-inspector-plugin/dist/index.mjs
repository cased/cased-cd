var c = Object.defineProperty, d = Object.defineProperties;
var m = Object.getOwnPropertyDescriptors;
var n = Object.getOwnPropertySymbols;
var f = Object.prototype.hasOwnProperty, a = Object.prototype.propertyIsEnumerable;
var o = (e, r, l) => r in e ? c(e, r, { enumerable: !0, configurable: !0, writable: !0, value: l }) : e[r] = l, u = (e, r) => {
  for (var l in r || (r = {}))
    f.call(r, l) && o(e, l, r[l]);
  if (n)
    for (var l of n(r))
      a.call(r, l) && o(e, l, r[l]);
  return e;
}, i = (e, r) => d(e, m(r));
import { ViteCodeInspectorPlugin as p } from "@code-inspector/vite";
import s from "@code-inspector/webpack";
import { EsbuildCodeInspectorPlugin as b } from "@code-inspector/esbuild";
import { TurbopackCodeInspectorPlugin as g } from "@code-inspector/turbopack";
import { MakoCodeInspectorPlugin as P } from "@code-inspector/mako";
import { getEnvVariable as I, fileURLToPath as k, resetFileRecord as C } from "@code-inspector/core";
import h from "chalk";
import E, { dirname as _ } from "path";
function v(e) {
  if (!(e != null && e.bundler)) {
    console.log(
      h.red(
        "Please specify the bundler in the options of code-inspector-plugin."
      )
    );
    return;
  }
  let r = !1;
  e.needEnvInspector && (r = !0, I("CODE_INSPECTOR", process.cwd()) === "true" && (r = !1));
  let l = "";
  typeof __dirname != "undefined" ? l = __dirname : l = _(k(import.meta.url));
  const t = i(u({}, e), {
    close: r,
    output: E.resolve(l, "./")
  });
  return C(t.output), e.bundler === "webpack" || e.bundler === "rspack" ? new s(t) : e.bundler === "esbuild" ? b(t) : e.bundler === "turbopack" ? g(t) : e.bundler === "mako" ? P(t) : p(t);
}
const L = v;
export {
  v as CodeInspectorPlugin,
  L as codeInspectorPlugin
};
